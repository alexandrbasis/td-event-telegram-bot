import logging
from logging.handlers import RotatingFileHandler
import re
from typing import List, Dict, Optional
from dataclasses import asdict
import time
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from functools import wraps
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    ConversationHandler,
    MessageHandler,
    CallbackQueryHandler,
    filters,
)
from config import BOT_TOKEN, BOT_USERNAME, COORDINATOR_IDS, VIEWER_IDS
from utils.decorators import require_role
from utils.cache import load_reference_data
from utils.timeouts import set_edit_timeout, clear_expired_edit
from database import init_database
from repositories.participant_repository import SqliteParticipantRepository
from services.participant_service import ParticipantService
from parsers.participant_parser import (
    parse_participant_data,
    is_template_format,
    parse_template_format,
    parse_unstructured_text,
)
from services.participant_service import (
    merge_participant_data,
    format_participant_block,
    detect_changes,
    update_single_field,
    get_edit_keyboard,
    FIELD_LABELS,
    get_gender_selection_keyboard,
    get_role_selection_keyboard,
    get_size_selection_keyboard,
    get_department_selection_keyboard,
)
from utils.validators import validate_participant_data
from utils.exceptions import (
    BotException,
    ParticipantNotFoundError,
    ValidationError,
    DatabaseError,
)
from messages import MESSAGES
from states import CONFIRMING_DATA, CONFIRMING_DUPLICATE, COLLECTING_DATA


def smart_cleanup_on_error(func):
    """
    –£–ª—É—á—à–µ–Ω–Ω—ã–π –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ—à–∏–±–æ–∫ —Å —É–º–Ω–æ–π –æ—á–∏—Å—Ç–∫–æ–π —Å–æ—Å—Ç–æ—è–Ω–∏—è.

    –õ–æ–≥–∏–∫–∞:
    - ValidationError, ParticipantNotFoundError ‚Üí —Å–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    - DatabaseError, BotException ‚Üí –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    - –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –æ—à–∏–±–∫–∏ ‚Üí –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
    """

    @wraps(func)
    async def wrapper(
        update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs
    ):
        user_id = update.effective_user.id if update.effective_user else "unknown"

        try:
            return await func(update, context, *args, **kwargs)

        except ValidationError as e:
            # –û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ - –æ—Å—Ç–∞—ë–º—Å—è –≤ —Ç–µ–∫—É—â–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            logger.warning(
                f"Validation error for user {user_id} in {func.__name__}: {e}"
            )
            try:
                if update.message:
                    await update.message.reply_text(
                        f"‚ùå **–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏:**\n{e}", parse_mode="Markdown"
                    )
                elif update.callback_query:
                    await update.callback_query.answer()
                    await update.callback_query.message.reply_text(
                        f"‚ùå **–û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏:**\n{e}", parse_mode="Markdown"
                    )
            except Exception as send_error:
                logger.error(
                    f"Failed to send validation error to user {user_id}: {send_error}"
                )

            # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ - –ù–ï –∑–∞–≤–µ—Ä—à–∞–µ–º —Ä–∞–∑–≥–æ–≤–æ—Ä
            current_state = context.user_data.get("current_state", CONFIRMING_DATA)
            return current_state

        except ParticipantNotFoundError as e:
            # –£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω - –æ—Å—Ç–∞—ë–º—Å—è –≤ —Å–æ—Å—Ç–æ—è–Ω–∏–∏
            logger.warning(
                f"Participant not found for user {user_id} in {func.__name__}: {e}"
            )
            try:
                if update.message:
                    await update.message.reply_text(
                        f"‚ùå **–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω:**\n{e}", parse_mode="Markdown"
                    )
                elif update.callback_query:
                    await update.callback_query.answer()
                    await update.callback_query.message.reply_text(
                        f"‚ùå **–£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω:**\n{e}", parse_mode="Markdown"
                    )
            except Exception as send_error:
                logger.error(
                    f"Failed to send not found error to user {user_id}: {send_error}"
                )

            return CONFIRMING_DATA

        except AttributeError as e:
            if "job_queue" in str(e) or "run_once" in str(e):
                logger.error(f"JobQueue error for user {user_id}: {e}")
                try:
                    if update.message:
                        await update.message.reply_text(
                            "‚ö†Ô∏è –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞ —Å —Ç–∞–π–º–µ—Ä–∞–º–∏. –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.\n"
                            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
                        )
                    elif update.callback_query:
                        await update.callback_query.answer()
                        await update.callback_query.message.reply_text(
                            "‚ö†Ô∏è –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø—Ä–æ–±–ª–µ–º–∞ —Å —Ç–∞–π–º–µ—Ä–∞–º–∏. –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ.\n"
                            "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
                        )
                except Exception as send_error:
                    logger.error(
                        f"Failed to send timer error message to user {user_id}: {send_error}"
                    )
                participant_data = context.user_data.get("parsed_participant")
                if participant_data:
                    await show_confirmation(update, context, participant_data)
                return context.user_data.get("current_state", CONFIRMING_DATA)
            else:
                raise

        except (DatabaseError, BotException) as e:
            # –°–µ—Ä—å—ë–∑–Ω—ã–µ –æ—à–∏–±–∫–∏ - –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            logger.error(
                f"Critical error for user {user_id} in {func.__name__}: {type(e).__name__}: {e}"
            )
            cleanup_user_data_safe(
                context, user_id if isinstance(user_id, int) else None
            )

            try:
                if update.message:
                    await update.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add\n"
                        "üìû –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                        parse_mode="Markdown",
                    )
                elif update.callback_query:
                    await update.callback_query.answer()
                    await update.callback_query.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add",
                        parse_mode="Markdown",
                    )
            except Exception as send_error:
                logger.error(
                    f"Failed to send critical error message to user {user_id}: {send_error}"
                )

            return ConversationHandler.END

        except Exception as e:
            # –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–µ –æ—à–∏–±–∫–∏ - –æ—á–∏—â–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏
            logger.error(
                f"Unexpected error for user {user_id} in {func.__name__}: {type(e).__name__}: {e}",
                exc_info=True,
            )
            cleanup_user_data_safe(
                context, user_id if isinstance(user_id, int) else None
            )

            try:
                if update.message:
                    await update.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add\n"
                        "üìû –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                        parse_mode="Markdown",
                    )
                elif update.callback_query:
                    await update.callback_query.answer()
                    await update.callback_query.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–∞—è –æ—à–∏–±–∫–∞.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add",
                        parse_mode="Markdown",
                    )
            except Exception as send_error:
                logger.error(
                    f"Failed to send unexpected error message to user {user_id}: {send_error}"
                )

            return ConversationHandler.END

    return wrapper


def cleanup_on_error(func):
    """–î–µ–∫–æ—Ä–∞—Ç–æ—Ä –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–π –æ—á–∏—Å—Ç–∫–∏ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö."""

    @wraps(func)
    async def wrapper(
        update: Update, context: ContextTypes.DEFAULT_TYPE, *args, **kwargs
    ):
        try:
            return await func(update, context, *args, **kwargs)
        except Exception as e:
            user_id = update.effective_user.id if update.effective_user else "unknown"
            logger.error(
                f"Error in {func.__name__} for user {user_id}: {type(e).__name__}: {e}",
                exc_info=True,
            )

            cleanup_user_data_safe(context, update.effective_user.id)
            logger.info(
                f"Cleared user_data for user {user_id} due to error in {func.__name__}"
            )

            try:
                if update.message:
                    await update.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add\n"
                        "üìû –ï—Å–ª–∏ –ø—Ä–æ–±–ª–µ–º–∞ –ø–æ–≤—Ç–æ—Ä—è–µ—Ç—Å—è, –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.",
                        parse_mode="Markdown",
                    )
                elif update.callback_query:
                    await update.callback_query.answer()
                    await update.callback_query.message.reply_text(
                        "‚ùå **–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±—Ä–∞–±–æ—Ç–∫–µ –¥–∞–Ω–Ω—ã—Ö.**\n\n"
                        "üîÑ –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –∫–æ–º–∞–Ω–¥—ã /add",
                        parse_mode="Markdown",
                    )
            except Exception as send_error:
                logger.error(
                    f"Failed to send error message to user {user_id}: {send_error}"
                )

            return ConversationHandler.END

    return wrapper


def cleanup_user_data_safe(context: ContextTypes.DEFAULT_TYPE, user_id: int = None):
    """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ user_data —Å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ–º."""

    if context.user_data:
        keys_to_clear = list(context.user_data.keys())
        context.user_data.clear()
        logger.info(
            f"Manually cleared user_data for user {user_id or 'unknown'}: removed keys {keys_to_clear}"
        )
    else:
        logger.debug(f"user_data already empty for user {user_id or 'unknown'}")


# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ ---


def _add_message_to_cleanup(context: ContextTypes.DEFAULT_TYPE, message_id: int):
    """–î–æ–±–∞–≤–ª—è–µ—Ç ID —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —Å–ø–∏—Å–æ–∫ –¥–ª—è –ø–æ—Å–ª–µ–¥—É—é—â–µ–π –æ—á–∏—Å—Ç–∫–∏."""
    if "messages_to_delete" not in context.user_data:
        context.user_data["messages_to_delete"] = []
    context.user_data["messages_to_delete"].append(message_id)


async def _cleanup_messages(context: ContextTypes.DEFAULT_TYPE, chat_id: int):
    """–£–¥–∞–ª—è–µ—Ç –≤—Å–µ —Å–æ–æ–±—â–µ–Ω–∏—è, —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–µ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏."""
    messages_to_delete = context.user_data.get("messages_to_delete", [])
    for message_id in messages_to_delete:
        try:
            await context.bot.delete_message(chat_id=chat_id, message_id=message_id)
        except Exception as e:
            logger.warning("Could not delete message %d: %s", message_id, e)

    if "messages_to_delete" in context.user_data:
        context.user_data["messages_to_delete"].clear()


async def clear_field_to_edit(context: ContextTypes.DEFAULT_TYPE) -> None:
    """Removes stale field editing context for a user."""
    if context.job:
        user_id = context.job.data
        user_data = context.application.user_data.get(user_id, {})
    else:
        user_id = None
        user_data = context.user_data
    if user_data.pop("field_to_edit", None):
        logger.info("Cleared stale field_to_edit for user %s", user_id)
    job = user_data.pop("clear_edit_job", None)
    if job:
        job.schedule_removal()
    user_data.pop("edit_timeout", None)


# --- –ö–æ–Ω–µ—Ü –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã—Ö —Ñ—É–Ω–∫—Ü–∏–π ---


# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
LOG_FORMAT = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
handler = RotatingFileHandler("bot.log", maxBytes=10 * 1024 * 1024, backupCount=5)
handler.setFormatter(logging.Formatter(LOG_FORMAT))

# –û—Ç–¥–µ–ª—å–Ω—ã–π –ª–æ–≥ –¥–ª—è SQL-–∑–∞–ø—Ä–æ—Å–æ–≤
sql_handler = RotatingFileHandler("sql.log", maxBytes=10 * 1024 * 1024, backupCount=5)
sql_handler.setFormatter(logging.Formatter(LOG_FORMAT))
sql_logger = logging.getLogger("sql")
sql_logger.addHandler(sql_handler)


def setup_logging():
    """Configure logging levels for production."""
    logging.basicConfig(level=logging.INFO, handlers=[handler], format=LOG_FORMAT)
    # logging.getLogger(__name__).setLevel(logging.DEBUG)
    sql_logger.setLevel(logging.WARNING)


setup_logging()

logger = logging.getLogger(__name__)

# Timeout in seconds to wait for user input when editing a specific field
FIELD_EDIT_TIMEOUT = 300

# Initialize repository and service instances
participant_repository = SqliteParticipantRepository()
participant_service = ParticipantService(repository=participant_repository)

# --- REQUIRED AND OPTIONAL FIELDS ---
REQUIRED_FIELDS = ["FullNameRU", "Gender", "Size", "Church", "Role"]
OPTIONAL_FIELDS = [
    "FullNameEN",
    "CountryAndCity",
    "SubmittedBy",
    "ContactInformation",
    "Department",
]


# –§—É–Ω–∫—Ü–∏—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
def get_user_role(user_id):
    if user_id in COORDINATOR_IDS:
        return "coordinator"
    elif user_id in VIEWER_IDS:
        return "viewer"
    else:
        return "unauthorized"


async def show_confirmation(
    update: Update, context: ContextTypes.DEFAULT_TYPE, participant_data: Dict
) -> None:
    """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —Å –¥–∞–Ω–Ω—ã–º–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."""
    user_id = update.effective_user.id
    logger.info(f"Showing confirmation for user {user_id}")
    logger.debug(f"user_data keys: {list(context.user_data.keys())}")
    confirmation_text = "üîç –í–æ—Ç —á—Ç–æ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å. –í—Å—ë –ø—Ä–∞–≤–∏–ª—å–Ω–æ?\n\n"
    confirmation_text += format_participant_block(participant_data)
    confirmation_text += '\n\n‚úÖ –ù–∞–∂–º–∏—Ç–µ "–°–æ—Ö—Ä–∞–Ω–∏—Ç—å", —á—Ç–æ–±—ã –∑–∞–≤–µ—Ä—à–∏—Ç—å, –∏–ª–∏ –≤—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è.'
    keyboard = get_edit_keyboard(participant_data)
    logger.debug(f"Generated keyboard with {len(keyboard.inline_keyboard)} rows")
    if logger.isEnabledFor(logging.DEBUG):
        for i, row in enumerate(keyboard.inline_keyboard):
            for j, button in enumerate(row):
                logger.debug(
                    f"Button [{i}][{j}]: text='{button.text}', callback_data='{button.callback_data}'"
                )

    message = update.effective_message
    msg = await message.reply_text(
        confirmation_text,
        parse_mode="Markdown",
        reply_markup=keyboard,
    )
    _add_message_to_cleanup(context, msg.message_id)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ –¥–ª—è –¥–µ–∫–æ—Ä–∞—Ç–æ—Ä–∞
    context.user_data["current_state"] = CONFIRMING_DATA


def get_duplicate_keyboard() -> InlineKeyboardMarkup:
    """Keyboard for handling duplicate participant decisions."""
    keyboard = [
        [
            InlineKeyboardButton("‚úÖ –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤—ã–π", callback_data="dup_add_new"),
            InlineKeyboardButton("üîÑ –ó–∞–º–µ–Ω–∏—Ç—å", callback_data="dup_replace"),
        ],
        [InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="main_cancel")],
    ]
    return InlineKeyboardMarkup(keyboard)


def get_post_action_keyboard() -> InlineKeyboardMarkup:
    """Keyboard shown after successful add/update."""
    keyboard = [
        [
            InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â–µ", callback_data="main_add"),
            InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="main_list"),
        ],
        [InlineKeyboardButton("üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")],
    ]
    return InlineKeyboardMarkup(keyboard)


def get_no_changes_keyboard() -> InlineKeyboardMarkup:
    """Keyboard shown when no changes were detected during editing."""
    keyboard = [
        [
            InlineKeyboardButton(
                "\ud83d\udd04 \u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u044c \u0440\u0435\u0434\u0430\u043a\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435",
                callback_data="continue_editing",
            )
        ],
        [
            InlineKeyboardButton(
                "\u2705 \u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u043a\u0430\u043a \u0435\u0441\u0442\u044c",
                callback_data="confirm_save",
            )
        ],
        [
            InlineKeyboardButton(
                "\u274c \u041e\u0442\u043c\u0435\u043d\u0438\u0442\u044c",
                callback_data="main_cancel",
            )
        ],
    ]
    return InlineKeyboardMarkup(keyboard)


def _get_return_to_menu_keyboard() -> InlineKeyboardMarkup:
    """–°–æ–∑–¥–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–æ–π –≤–æ–∑–≤—Ä–∞—Ç–∞ –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é."""
    keyboard = [[InlineKeyboardButton("üè† –í –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", callback_data="main_menu")]]
    return InlineKeyboardMarkup(keyboard)


async def _send_response_with_menu_button(
    update: Update,
    text: str,
    *,
    parse_mode: str = "Markdown",
) -> None:
    """Reply with text and a 'Return to menu' button for both command and callback handlers."""
    try:
        if update.callback_query:
            await update.callback_query.message.reply_text(
                text,
                parse_mode=parse_mode,
                reply_markup=_get_return_to_menu_keyboard(),
            )
        else:
            await update.message.reply_text(
                text,
                parse_mode=parse_mode,
                reply_markup=_get_return_to_menu_keyboard(),
            )
    except Exception as e:  # pragma: no cover - just log
        logger.error(f"Error sending response with menu button: {e}")
        if update.callback_query:
            await update.callback_query.message.reply_text(text, parse_mode=parse_mode)
        else:
            await update.message.reply_text(text, parse_mode=parse_mode)


# --- HELPER FUNCTIONS (NEW) ---


def get_missing_fields(participant_data: Dict) -> List[str]:
    """Checks for missing required fields."""
    missing = []
    for field in REQUIRED_FIELDS:
        if not participant_data.get(field):
            missing.append(FIELD_LABELS.get(field, field))

    if participant_data.get("Role") == "TEAM" and not participant_data.get(
        "Department"
    ):
        missing.append(FIELD_LABELS.get("Department", "Department"))
    return missing


def format_status_message(participant_data: Dict) -> str:
    """Creates a status message with filled data and missing fields."""
    message = "üìù **–ü—Ä–æ—Ü–µ—Å—Å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è:**\n\n"
    message += format_participant_block(participant_data)
    message += "\n\n"

    missing = get_missing_fields(participant_data)
    if missing:
        message += "üî¥ **–û—Å—Ç–∞–ª–æ—Å—å –∑–∞–ø–æ–ª–Ω–∏—Ç—å:**\n- " + "\n- ".join(missing)
        message += "\n\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–¥–Ω–æ–≥–æ –∏–∑ —ç—Ç–∏—Ö –ø–æ–ª–µ–π –∏–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ /cancel –¥–ª—è –æ—Ç–º–µ–Ω—ã."
    else:
        message += "‚úÖ **–í—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è –∑–∞–ø–æ–ª–Ω–µ–Ω—ã!**\n\n"
        message += "–û—Ç–ø—Ä–∞–≤—å—Ç–µ **–î–ê** –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–ª–∏ **–ù–ï–¢** –¥–ª—è –æ—Ç–º–µ–Ω—ã."

    return message


async def _show_main_menu(
    update: Update, context: ContextTypes.DEFAULT_TYPE, is_return: bool = False
) -> None:
    """Display the main menu, editing the existing message when possible."""
    user_id = update.effective_user.id
    role = get_user_role(user_id)

    if is_return:
        welcome_text = (
            "‚úÖ **–û–ø–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞.**\n\n" "–ß–µ–º –µ—â–µ —è –º–æ–≥—É –¥–ª—è –≤–∞—Å —Å–¥–µ–ª–∞—Ç—å?"
        )
    else:
        welcome_text = (
            "üèïÔ∏è **–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –±–æ—Ç Tres Dias Israel!**\n\n"
            f"üë§ –í–∞—à–∞ —Ä–æ–ª—å: **{role.title()}**"
        )

    keyboard: list[list[InlineKeyboardButton]]
    if user_id in COORDINATOR_IDS:
        keyboard = [
            [
                InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="main_add"),
                InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="main_list"),
            ],
            [
                InlineKeyboardButton("üì§ –≠–∫—Å–ø–æ—Ä—Ç", callback_data="main_export"),
                InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="main_help"),
            ],
        ]
    else:
        keyboard = [
            [
                InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="main_list"),
                InlineKeyboardButton("üì§ –≠–∫—Å–ø–æ—Ä—Ç", callback_data="main_export"),
            ],
            [InlineKeyboardButton("‚ÑπÔ∏è –ü–æ–º–æ—â—å", callback_data="main_help")],
        ]

    reply_markup = InlineKeyboardMarkup(keyboard)

    if update.callback_query:
        try:
            await update.callback_query.edit_message_text(
                text=welcome_text,
                parse_mode="Markdown",
                reply_markup=reply_markup,
            )
        except Exception:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=welcome_text,
                parse_mode="Markdown",
                reply_markup=reply_markup,
            )
    else:
        await update.effective_message.reply_text(
            text=welcome_text,
            parse_mode="Markdown",
            reply_markup=reply_markup,
        )


# –ö–æ–º–∞–Ω–¥–∞ /start
@require_role("viewer")
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Entry point that shows the main menu."""
    logger.info("User %s started /start", update.effective_user.id)
    await _cleanup_messages(context, update.effective_chat.id)
    await _show_main_menu(update, context)


@require_role("coordinator")
async def handle_add_callback(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Starts the add flow from the main menu button."""
    query = update.callback_query
    await query.answer()
    await query.edit_message_reply_markup(reply_markup=None)

    context.user_data["add_flow_data"] = {
        "FullNameRU": None,
        "Gender": None,
        "Size": None,
        "Church": None,
        "Role": None,
        "Department": None,
        "FullNameEN": None,
        "CountryAndCity": None,
        "SubmittedBy": None,
        "ContactInformation": None,
    }

    cancel_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="main_cancel")]]
    )

    msg1 = await query.message.reply_text(
        "üöÄ **–ù–∞—á–∏–Ω–∞–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞.**\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –ª—é–±—ã–º —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º:\n"
        "1Ô∏è‚É£ **–í—Å—Ç–∞–≤—å—Ç–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω** (–ø—Ä–∏—à–ª—é –µ–≥–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).\n"
        "2Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ–π**, —Ä–∞–∑–¥–µ–ª—è—è –∏—Ö –∑–∞–ø—è—Ç–æ–π (`,`) –∏–ª–∏ –∫–∞–∂–¥–æ–µ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–æ–π.\n"
        "3Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –ø–æ –æ–¥–Ω–æ–º—É –ø–æ–ª—é** –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `–¶–µ—Ä–∫–æ–≤—å –ì—Ä–µ–π—Å`).\n\n"
        "*–î–ª—è —Å–∞–º–æ–π —Ç–æ—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–ø—è—Ç—ã–µ –∏–ª–∏ –≤–≤–æ–¥ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.*\n"
        "–î–ª—è –æ—Ç–º–µ–Ω—ã –≤–≤–µ–¥–∏—Ç–µ /cancel.",
        parse_mode="Markdown",
        reply_markup=cancel_markup,
    )
    msg2 = await query.message.reply_text(MESSAGES["ADD_TEMPLATE"])
    _add_message_to_cleanup(context, msg1.message_id)
    _add_message_to_cleanup(context, msg2.message_id)
    _add_message_to_cleanup(context, query.message.message_id)
    return COLLECTING_DATA


@require_role("viewer")
async def handle_main_menu_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏—è –Ω–∞ –∫–Ω–æ–ø–∫–∏ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é."""
    query = update.callback_query
    await query.answer()
    data = query.data

    await query.edit_message_reply_markup(reply_markup=None)

    if data == "main_cancel":
        await _cleanup_messages(context, update.effective_chat.id)
        cleanup_user_data_safe(context, update.effective_user.id)
        await _show_main_menu(update, context, is_return=True)
        return

    if data == "main_menu":
        await _show_main_menu(update, context, is_return=True)
        return

    # main_list mirrors the /list command
    if data == "main_list":
        participants = participant_service.get_all_participants()
        if not participants:
            await query.message.reply_text(
                "üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—É—Å—Ç**\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /add –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.",
                parse_mode="Markdown",
            )
            return

        message = f"üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ ({len(participants)} —á–µ–ª.):**\n\n"
        for p in participants:
            role_emoji = "üë§" if p.Role == "CANDIDATE" else "üë®‚Äçüíº"
            department = (
                f" ({p.Department})" if p.Role == "TEAM" and p.Department else ""
            )
            message += f"{role_emoji} **{p.FullNameRU}**\n"
            message += f"   ‚Ä¢ –†–æ–ª—å: {p.Role}{department}\n"
            message += f"   ‚Ä¢ ID: {p.id}\n\n"

        await _send_response_with_menu_button(update, message)
        return

    # main_export mirrors the /export command
    if data == "main_export":
        await _send_response_with_menu_button(
            update,
            "üì§ **–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö** (–∑–∞–≥–ª—É—à–∫–∞)\n\n"
            "üîß –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.\n"
            "–ü—Ä–∏–º–µ—Ä: /export worship team - —ç–∫—Å–ø–æ—Ä—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ worship –∫–æ–º–∞–Ω–¥—ã",
        )
        return

    # main_help mirrors the /help command
    if data == "main_help":
        help_text = """
üìñ **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:**

üë• **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏:**
/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/delete - –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞

üìä **–ü—Ä–æ—Å–º–æ—Ç—Ä –¥–∞–Ω–Ω—ã—Ö:**
/list - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
/export - –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV

‚ùì **–ü–æ–º–æ—â—å:**
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é

üîç **–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤ (—Å–∫–æ—Ä–æ):**
"–°–∫–æ–ª—å–∫–æ team-member –≤ worship?"
"–ö—Ç–æ –∂–∏–≤–µ—Ç –≤ –∫–æ–º–Ω–∞—Ç–µ 203A?"
        """

        await _send_response_with_menu_button(update, help_text)
        return


# Equivalent to the main_help callback handler
# –ö–æ–º–∞–Ω–¥–∞ /help
@require_role("viewer")
async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    logger.info("User %s requested help", user_id)

    help_text = """
üìñ **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:**

üë• **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏:**
/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/delete - –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞

üìä **–ü—Ä–æ—Å–º–æ—Ç—Ä –¥–∞–Ω–Ω—ã—Ö:**
/list - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
/export - –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV

‚ùì **–ü–æ–º–æ—â—å:**
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é

üîç **–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤ (—Å–∫–æ—Ä–æ):**
"–°–∫–æ–ª—å–∫–æ team-member –≤ worship?"
"–ö—Ç–æ –∂–∏–≤–µ—Ç –≤ –∫–æ–º–Ω–∞—Ç–µ 203A?"
    """

    await _send_response_with_menu_button(update, help_text)


# –ö–æ–º–∞–Ω–¥–∞ /add
@require_role("coordinator")
@cleanup_on_error
async def add_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Starts the /add flow and initializes the session."""
    user_id = update.effective_user.id
    logger.info("User %s started add participant", user_id)

    context.user_data["add_flow_data"] = {
        "FullNameRU": None,
        "Gender": None,
        "Size": None,
        "Church": None,
        "Role": None,
        "Department": None,
        "FullNameEN": None,
        "CountryAndCity": None,
        "SubmittedBy": None,
        "ContactInformation": None,
    }

    cancel_markup = InlineKeyboardMarkup(
        [[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="main_cancel")]]
    )

    msg1 = await update.message.reply_text(
        "üöÄ **–ù–∞—á–∏–Ω–∞–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞.**\n\n"
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –ª—é–±—ã–º —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º:\n"
        "1Ô∏è‚É£ **–í—Å—Ç–∞–≤—å—Ç–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω** (–ø—Ä–∏—à–ª—é –µ–≥–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).\n"
        "2Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ–π**, —Ä–∞–∑–¥–µ–ª—è—è –∏—Ö –∑–∞–ø—è—Ç–æ–π (`,`) –∏–ª–∏ –∫–∞–∂–¥–æ–µ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n"
        "3Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –ø–æ –æ–¥–Ω–æ–º—É –ø–æ–ª—é** –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `–¶–µ—Ä–∫–æ–≤—å –ì—Ä–µ–π—Å`).\n\n"
        "*–î–ª—è —Å–∞–º–æ–π —Ç–æ—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–ø—è—Ç—ã–µ –∏–ª–∏ –≤–≤–æ–¥ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.*\n"
        "–î–ª—è –æ—Ç–º–µ–Ω—ã –≤–≤–µ–¥–∏—Ç–µ /cancel.",
        parse_mode="Markdown",
        reply_markup=cancel_markup,
    )
    msg2 = await update.message.reply_text(MESSAGES["ADD_TEMPLATE"])
    _add_message_to_cleanup(context, msg1.message_id)
    _add_message_to_cleanup(context, msg2.message_id)
    _add_message_to_cleanup(context, update.message.message_id)
    return COLLECTING_DATA


@require_role("coordinator")
@smart_cleanup_on_error
async def handle_partial_data(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Collects and processes partial data, supporting multiple formats."""
    user_id = update.effective_user.id
    text = update.message.text.strip()
    _add_message_to_cleanup(context, update.message.message_id)
    participant_data = context.user_data.get("add_flow_data", {})

    # 1. Check if user pasted a full template (highest priority)
    if is_template_format(text):
        parsed_update = parse_template_format(text)
        for key, value in parsed_update.items():
            if value:
                participant_data[key] = value
    else:
        # 2. Try splitting by newline or comma to detect multiple fields
        chunks = []
        if "\n" in text:
            chunks = [c.strip() for c in text.split("\n") if c.strip()]
        elif "," in text:
            chunks = [c.strip() for c in text.split(",") if c.strip()]
        else:
            chunks = [text]

        # Parse each chunk separately
        for chunk in chunks:
            if not chunk:
                continue

            if ":" in chunk:
                parsed_chunk = parse_participant_data(chunk, is_update=True)
            else:
                parsed_chunk = parse_participant_data(chunk, is_update=False)

            for key, value in parsed_chunk.items():
                if value:
                    participant_data[key] = value

    # --- NAME DUPLICATE CHECK BLOCK ---
    newly_identified_name = participant_data.get("FullNameRU")
    if newly_identified_name and not context.user_data.get("participant_id"):
        existing_participant = participant_service.check_duplicate(
            newly_identified_name
        )
        if existing_participant:
            context.user_data["participant_id"] = existing_participant.id
            existing_dict = asdict(existing_participant)
            context.user_data["add_flow_data"] = existing_dict
            context.user_data["parsed_participant"] = existing_dict
            await update.message.reply_text(
                f"‚ÑπÔ∏è –£—á–∞—Å—Ç–Ω–∏–∫ —Å –∏–º–µ–Ω–µ–º '{newly_identified_name}' —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü–µ—Ä–µ–∫–ª—é—á–∞—é—Å—å –≤ —Ä–µ–∂–∏–º —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è."
            )
            await show_confirmation(update, context, existing_dict)
            return CONFIRMING_DATA

    context.user_data["add_flow_data"] = participant_data

    missing_fields = get_missing_fields(participant_data)

    if not missing_fields:
        context.user_data["parsed_participant"] = participant_data

        logger.info(
            f"User {user_id} parsed participant data: {participant_data.get('FullNameRU', 'Unknown')}"
        )
        logger.debug(f"Saving participant data: {participant_data}")
        logger.debug(f"user_data after save: {context.user_data}")

        await show_confirmation(update, context, participant_data)
        context.user_data["current_state"] = CONFIRMING_DATA
        return CONFIRMING_DATA
    else:
        status_message = format_status_message(participant_data)
        cancel_markup = InlineKeyboardMarkup(
            [[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="main_cancel")]]
        )
        msg = await update.message.reply_text(
            status_message, parse_mode="Markdown", reply_markup=cancel_markup
        )
        _add_message_to_cleanup(context, msg.message_id)
        context.user_data["current_state"] = COLLECTING_DATA
        return COLLECTING_DATA


# –ö–æ–º–∞–Ω–¥–∞ /edit
@require_role("coordinator")
async def edit_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    logger.info("User %s started edit participant", user_id)

    await _send_response_with_menu_button(
        update,
        "‚úèÔ∏è **–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞** (–∑–∞–≥–ª—É—à–∫–∞)\n\n"
        "üîß –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.\n"
        "–ü—Ä–∏–º–µ—Ä: /edit 123 - —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ —Å ID 123",
    )


# –ö–æ–º–∞–Ω–¥–∞ /delete
@require_role("coordinator")
async def delete_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    logger.info("User %s started delete participant", user_id)

    await _send_response_with_menu_button(
        update,
        "üóëÔ∏è **–£–¥–∞–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞** (–∑–∞–≥–ª—É—à–∫–∞)\n\n"
        "üîß –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.\n"
        "–ü—Ä–∏–º–µ—Ä: /delete 123 - —É–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞ —Å ID 123",
    )


@require_role("coordinator")
async def edit_field_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    ‚úÖ –ù–û–í–ê–Ø –ö–û–ú–ê–ù–î–ê: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —á–∞—Å—Ç–∏—á–Ω–æ–≥–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ–ª–µ–π.

    –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: /edit_field 123 FullNameRU "–ù–æ–≤–æ–µ –∏–º—è"
    """
    try:
        parts = update.message.text.split(" ", 3)
        if len(parts) < 4:
            await update.message.reply_text(
                "‚ùå **–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:** /edit_field ID –ø–æ–ª–µ –∑–Ω–∞—á–µ–Ω–∏–µ\n\n"
                '**–ü—Ä–∏–º–µ—Ä:** /edit_field 123 FullNameRU "–ù–æ–≤–æ–µ –∏–º—è"',
                parse_mode="Markdown",
            )
            return

        _, participant_id, field_name, new_value = parts
        participant_id = int(participant_id)

        if not participant_service.participant_exists(participant_id):
            await update.message.reply_text(
                f"‚ùå –£—á–∞—Å—Ç–Ω–∏–∫ —Å ID {participant_id} –Ω–µ –Ω–∞–π–¥–µ–Ω"
            )
            return

        kwargs = {field_name: new_value}
        success = participant_service.update_participant_fields(
            participant_id, **kwargs
        )

        if success:
            await update.message.reply_text(
                f"‚úÖ **–ü–æ–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!**\n\n"
                f"üÜî ID: {participant_id}\n"
                f"üìù –ü–æ–ª–µ: {field_name}\n"
                f"üîÑ –ù–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: {new_value}",
                parse_mode="Markdown",
            )
        else:
            await update.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—è")

    except ValueError as e:
        await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")
    except ParticipantNotFoundError as e:
        await update.message.reply_text(f"‚ùå {e}")
    except Exception as e:
        logger.error("Error in edit_field_command: %s", e)
        await update.message.reply_text("‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –ø–æ–ª—è")


# –ö–æ–º–∞–Ω–¥–∞ /list
# Equivalent to the main_list callback handler
@require_role("viewer")
async def list_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    logger.info("User %s requested participants list", user_id)

    # ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï: –∏—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π service –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
    participants = participant_service.get_all_participants()

    if not participants:
        await update.message.reply_text(
            "üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—É—Å—Ç**\n\n–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /add –¥–ª—è –¥–æ–±–∞–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.",
            parse_mode="Markdown",
        )
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    message = f"üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ ({len(participants)} —á–µ–ª.):**\n\n"

    for p in participants:
        role_emoji = "üë§" if p.Role == "CANDIDATE" else "üë®‚Äçüíº"
        department = f" ({p.Department})" if p.Role == "TEAM" and p.Department else ""

        message += f"{role_emoji} **{p.FullNameRU}**\n"
        message += f"   ‚Ä¢ –†–æ–ª—å: {p.Role}{department}\n"
        message += f"   ‚Ä¢ ID: {p.id}\n\n"

    await _send_response_with_menu_button(update, message)


# –ö–æ–º–∞–Ω–¥–∞ /export
# Equivalent to the main_export callback handler
@require_role("viewer")
async def export_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    role = get_user_role(user_id)
    logger.info("User %s requested export", user_id)

    await _send_response_with_menu_button(
        update,
        "üì§ **–≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö** (–∑–∞–≥–ª—É—à–∫–∞)\n\n"
        "üîß –§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.\n"
        "–ü—Ä–∏–º–µ—Ä: /export worship team - —ç–∫—Å–ø–æ—Ä—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ worship –∫–æ–º–∞–Ω–¥—ã",
    )


# –ö–æ–º–∞–Ω–¥–∞ /cancel
@require_role("viewer")
async def cancel_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if context.user_data:
        context.user_data.clear()
        logger.info("User %s cancelled the add flow.", user_id)
    else:
        logger.info("User %s cancelled a non-existent operation.", user_id)

    await _cleanup_messages(context, update.effective_chat.id)
    await _show_main_menu(update, context, is_return=True)
    return ConversationHandler.END


async def cancel_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Handle cancel buttons and return to the main menu."""
    query = update.callback_query
    user_id = update.effective_user.id

    logger.info(f"User {user_id} cancelled operation via {query.data}")

    await query.answer()

    await _cleanup_messages(context, update.effective_chat.id)
    cleanup_user_data_safe(context, update.effective_user.id)
    await _show_main_menu(update, context, is_return=True)
    return ConversationHandler.END


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –∏ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —É—á–∞—Å—Ç–Ω–∏–∫–∞
async def process_participant_confirmation(
    update: Update,
    context: ContextTypes.DEFAULT_TYPE,
    text: str,
    is_update: bool = False,
) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤–≤–æ–¥ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —ç—Ç–∞–ø–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."""

    # –ö–æ–ø–∏—è —Ç–µ–∫—Å—Ç–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –∏–ª–∏ –µ–≥–æ —á–∞—Å—Ç–∏ –º–æ–∂–µ—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    is_block = "–ò–º—è (—Ä—É—Å):" in text and "–ü–æ–ª:" in text
    if text.startswith("üîç") or "–í–æ—Ç —á—Ç–æ —è –ø–æ–Ω—è–ª" in text or is_block:
        parsed = parse_template_format(text)
    else:
        parsed = parse_participant_data(text, is_update=is_update)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–æ —Ç–æ—á–µ—á–Ω—ã–º –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∏–ª–∏ –º–∞—Å—Å–æ–≤—ã–º –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
    existing = context.user_data.get("parsed_participant", {}) if is_update else {}

    if is_update:
        participant_data = merge_participant_data(existing, parsed)
    else:
        participant_data = parsed

    valid, error = validate_participant_data(participant_data)
    if not valid:
        logger.error("Parsing error: %s | Text: %s", error, text)
        await update.message.reply_text(f"‚ùå {error}")
        return COLLECTING_DATA

    existing_participant = None
    if not is_update:
        existing_participant = participant_service.check_duplicate(
            participant_data["FullNameRU"]
        )

    if existing_participant:
        # –ù–∞–π–¥–µ–Ω –¥—É–±–ª—å - –æ–±—ä–µ–¥–∏–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –∏ –Ω–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        merged_data = merge_participant_data(existing_participant, participant_data)
        context.user_data["parsed_participant"] = merged_data
        context.user_data["duplicate"] = True

        duplicate_warning = f"""
‚ö†Ô∏è **–í–ù–ò–ú–ê–ù–ò–ï: –£—á–∞—Å—Ç–Ω–∏–∫ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç!**

üÜî **–°—É—â–µ—Å—Ç–≤—É—é—â–∏–π —É—á–∞—Å—Ç–Ω–∏–∫ (ID: {existing_participant.id}):**
üë§ –ò–º—è: {existing_participant.FullNameRU}
‚ö• –ü–æ–ª: {existing_participant.Gender}
üë• –†–æ–ª—å: {existing_participant.Role}
‚õ™ –¶–µ—Ä–∫–æ–≤—å: {existing_participant.Church}

üîÑ **–ù–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ:**
üë§ –ò–º—è: {participant_data['FullNameRU']}
‚ö• –ü–æ–ª: {participant_data['Gender']}
üë• –†–æ–ª—å: {participant_data['Role']}
‚õ™ –¶–µ—Ä–∫–æ–≤—å: {participant_data['Church']}

‚ùì **–ß—Ç–æ –¥–µ–ª–∞—Ç—å?**
- **–î–ê** - –¥–æ–±–∞–≤–∏—Ç—å –∫–∞–∫ –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ (–≤–æ–∑–º–æ–∂–µ–Ω –¥—É–±–ª—å)
- **–ù–ï–¢** - –æ—Ç–º–µ–Ω–∏—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ
- **–ó–ê–ú–ï–ù–ò–¢–¨** - –∑–∞–º–µ–Ω–∏—Ç—å —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞ –Ω–æ–≤—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏

‚ùå /cancel –¥–ª—è –ø–æ–ª–Ω–æ–π –æ—Ç–º–µ–Ω—ã
        """

        await update.message.reply_text(
            duplicate_warning,
            parse_mode="Markdown",
            reply_markup=get_duplicate_keyboard(),
        )
        return CONFIRMING_DUPLICATE

    if is_update:
        changes = detect_changes(existing, participant_data)
        if not changes:
            await update.message.reply_text(
                "–ò–∑–º–µ–Ω–µ–Ω–∏–π –Ω–µ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–æ. –í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                reply_markup=get_no_changes_keyboard(),
            )
            return CONFIRMING_DATA

        context.user_data["parsed_participant"] = participant_data
        context.user_data["duplicate"] = False
        confirmation_text = (
            "üîÑ **–ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö:**\n\n"
            "‚úèÔ∏è **–ò–∑–º–µ–Ω–µ–Ω–æ:**\n"
            + "\n".join(changes)
            + "\n\nüë§ **–ò—Ç–æ–≥–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ:**\n"
            + format_participant_block(participant_data)
            + "\n\n‚úÖ **–ß—Ç–æ –¥–µ–ª–∞—Ç—å –¥–∞–ª—å—à–µ?**\n"
            "- –ù–∞–ø–∏—à–∏—Ç–µ **–î–ê** –∏–ª–∏ **–ù–ï–¢**\n"
            "- –ò–ª–∏ –ø—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤—ã–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è"
            + "\n\n‚úèÔ∏è **–ß—Ç–æ–±—ã –∏—Å–ø—Ä–∞–≤–∏—Ç—å –ø–æ–ª–µ, –Ω–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ.**"
        )

        keyboard = get_edit_keyboard(participant_data)

        await update.message.reply_text(
            confirmation_text,
            parse_mode="Markdown",
            reply_markup=keyboard,
        )
        return CONFIRMING_DATA

    # –î—É–±–ª–µ–π –Ω–µ—Ç - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –æ–±—ã—á–Ω–æ–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ
    context.user_data["parsed_participant"] = participant_data
    context.user_data["duplicate"] = False

    await show_confirmation(update, context, participant_data)
    return CONFIRMING_DATA


@require_role("coordinator")
@smart_cleanup_on_error
async def handle_save_confirmation(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Handles the final confirmation via the 'Save' button."""
    query = update.callback_query
    user_id = update.effective_user.id

    logger.info(f"Save confirmation requested by user {user_id}")
    logger.debug(f"callback_data: {query.data}")
    logger.debug(f"user_data keys: {list(context.user_data.keys())}")

    await query.answer()
    await _cleanup_messages(context, update.effective_chat.id)

    participant_data = context.user_data.get("parsed_participant", {})
    if not participant_data:
        await query.message.reply_text(
            "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
        )
        cleanup_user_data_safe(context, update.effective_user.id)
        return ConversationHandler.END

    is_update = "participant_id" in context.user_data

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç (—Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –Ω–æ–≤–æ–≥–æ)
    if not is_update:
        existing = participant_service.check_duplicate(
            participant_data.get("FullNameRU")
        )
        if existing:
            context.user_data["existing_participant_id"] = existing.get("id")
            message = "‚ö†Ô∏è **–ù–∞–π–¥–µ–Ω –¥—É–±–ª–∏–∫–∞—Ç!**\n\n"
            message += format_participant_block(existing)
            message += "\n\n–ß—Ç–æ –¥–µ–ª–∞–µ–º?"
            await query.message.reply_text(
                message,
                parse_mode="Markdown",
                reply_markup=get_duplicate_keyboard(),
            )
            return CONFIRMING_DUPLICATE

    # –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    try:
        if is_update:
            participant_id = context.user_data["participant_id"]
            participant_service.update_participant(participant_id, participant_data)
            logger.info(
                f"‚úÖ User {user_id} successfully updated participant {participant_id}"
            )
            success_message = f"‚úÖ **–£—á–∞—Å—Ç–Ω–∏–∫ {participant_data['FullNameRU']} (ID: {participant_id}) —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!**"
        else:
            new_participant = participant_service.add_participant(participant_data)
            logger.info(
                f"‚úÖ User {user_id} successfully added participant {new_participant.id}: {new_participant.FullNameRU}"
            )
            success_message = f"‚úÖ **–£—á–∞—Å—Ç–Ω–∏–∫ {new_participant.FullNameRU} (ID: {new_participant.id}) —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω!**"

        await query.message.reply_text(
            success_message,
            parse_mode="Markdown",
            reply_markup=get_post_action_keyboard(),
        )
    except (DatabaseError, BotException, ValidationError) as e:
        logger.error("Error during save confirmation: %s", e)
        await query.message.reply_text(f"‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞: {e}")

    cleanup_user_data_safe(context, update.effective_user.id)
    return ConversationHandler.END


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –∫–æ–º–∞–Ω–¥ –∏ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
@require_role("viewer")
async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    message_text = update.message.text.strip()
    logger.info("User %s sent message: %s", user_id, message_text)

    # –û—Ç–ª–∞–¥–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    logger.info(f"User {user_id} state: {context.user_data}")

    # –í –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –±—É–¥–µ—Ç NLP –æ–±—Ä–∞–±–æ—Ç–∫–∞
    await update.message.reply_text(
        f'ü§ñ –ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ: "{message_text}"\n\n'
        "üîß NLP –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ.\n"
        "–ü–æ–∫–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—ã: /help –¥–ª—è —Å–ø—Ä–∞–≤–∫–∏.",
        parse_mode="Markdown",
    )


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
@require_role("coordinator")
@smart_cleanup_on_error
async def handle_participant_confirmation(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç–æ–≤—ã–π –≤–≤–æ–¥ –Ω–∞ —ç—Ç–∞–ø–µ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è (—Ç–æ–ª—å–∫–æ –¥–ª—è –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–π)."""
    user_id = update.effective_user.id
    text = update.message.text.strip()

    logger.debug(
        "Confirmation handler context for user %s: %s", user_id, context.user_data
    )

    if clear_expired_edit(context):
        await update.message.reply_text(
            "‚è≥ –í—Ä–µ–º—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏—Å—Ç–µ–∫. –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ —Å–Ω–æ–≤–∞ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ /cancel."
        )
        return CONFIRMING_DATA

    field_to_edit = context.user_data.get("field_to_edit")
    clear_job = context.user_data.pop("clear_edit_job", None)
    if clear_job:
        clear_job.schedule_removal()

    if field_to_edit:
        participant_data = context.user_data.get("parsed_participant", {})
        logger.info(
            "User %s editing field %s with value: %s", user_id, field_to_edit, text
        )

        try:
            updated_data, changes = update_single_field(
                participant_data, field_to_edit, text
            )
        except ValidationError:
            error_text = MESSAGES["VALIDATION_ERRORS"].get(
                field_to_edit, f"–ù–µ–¥–æ–ø—É—Å—Ç–∏–º–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—è {field_to_edit}"
            )
            await update.message.reply_text(f"‚ùå {error_text}")

            if context.job_queue:
                timeout_job = context.job_queue.run_once(
                    clear_field_to_edit, FIELD_EDIT_TIMEOUT, data=user_id
                )
                context.user_data["clear_edit_job"] = timeout_job
            else:
                logger.warning(
                    "JobQueue not available for user %s, skipping timeout job",
                    user_id,
                )
                set_edit_timeout(context, user_id, FIELD_EDIT_TIMEOUT)
            return CONFIRMING_DATA

        context.user_data["parsed_participant"] = updated_data
        context.user_data.pop("field_to_edit", None)

        logger.info("Changes after edit: %s", "; ".join(changes) or "no changes")

        await show_confirmation(update, context, updated_data)
        return CONFIRMING_DATA

    logger.warning(
        "field_to_edit missing in context for user %s during confirmation", user_id
    )

    # –¢–µ–ø–µ—Ä—å —ç—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è, –æ—Ç–ø—Ä–∞–≤–ª—è—è –∏—Ö –≤ process_participant_confirmation
    # –õ–æ–≥–∏–∫–∞ –î–ê/–ù–ï–¢ –ø–æ–ª–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∞ –∏ –∑–∞–º–µ–Ω–µ–Ω–∞ –∫–Ω–æ–ø–∫–æ–π
    await process_participant_confirmation(update, context, text, is_update=True)
    return CONFIRMING_DATA


@smart_cleanup_on_error
async def edit_field_callback(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –Ω–∞–∂–∞—Ç–∏–µ –Ω–∞ –∫–Ω–æ–ø–∫—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –ø–æ–ª—è."""
    query = update.callback_query
    await query.answer()

    _add_message_to_cleanup(context, query.message.message_id)

    field_to_edit = query.data.split("_")[1]
    user_id = update.effective_user.id
    logger.info("User %s selected field %s for editing", user_id, field_to_edit)

    # Save field in context and start timeout job
    context.user_data["field_to_edit"] = field_to_edit

    if job := context.user_data.get("clear_edit_job"):
        job.schedule_removal()

    if context.job_queue:
        timeout_job = context.job_queue.run_once(
            clear_field_to_edit, FIELD_EDIT_TIMEOUT, data=user_id
        )
        context.user_data["clear_edit_job"] = timeout_job
    else:
        logger.warning(
            f"JobQueue not available for user {user_id}, skipping timeout job"
        )
        set_edit_timeout(context, user_id, FIELD_EDIT_TIMEOUT)

    keyboard_map = {
        "Gender": get_gender_selection_keyboard,
        "Role": get_role_selection_keyboard,
        "Size": get_size_selection_keyboard,
        "Department": get_department_selection_keyboard,
    }

    if field_to_edit in keyboard_map:
        kb = keyboard_map[field_to_edit]()
        msg = await query.message.reply_text("–í—ã–±–µ—Ä–∏—Ç–µ –∑–Ω–∞—á–µ–Ω–∏–µ:", reply_markup=kb)
    else:
        msg = await query.message.reply_text(
            f"–ü—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—è **{field_to_edit}**",
            parse_mode="Markdown",
        )
    _add_message_to_cleanup(context, msg.message_id)

    return CONFIRMING_DATA


@smart_cleanup_on_error
async def handle_enum_selection(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –≤—ã–±–æ—Ä –∑–Ω–∞—á–µ–Ω–∏—è –∏–∑ enum-–∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã –∏–ª–∏ –ø–µ—Ä–µ—Ö–æ–¥ –∫ —Ä—É—á–Ω–æ–º—É –≤–≤–æ–¥—É."""
    query = update.callback_query
    await query.answer()

    data = query.data
    user_id = update.effective_user.id

    if data.startswith("manual_input_"):
        field = data.split("_", 1)[1]
        context.user_data["field_to_edit"] = field

        if job := context.user_data.get("clear_edit_job"):
            job.schedule_removal()
        if context.job_queue:
            timeout_job = context.job_queue.run_once(
                clear_field_to_edit, FIELD_EDIT_TIMEOUT, data=user_id
            )
            context.user_data["clear_edit_job"] = timeout_job
        else:
            logger.warning(
                f"JobQueue not available for user {user_id}, skipping timeout job"
            )
            set_edit_timeout(context, user_id, FIELD_EDIT_TIMEOUT)

        msg = await query.message.reply_text(
            f"–ü—Ä–∏—à–ª–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—è **{field}**",
            parse_mode="Markdown",
        )
        _add_message_to_cleanup(context, msg.message_id)
        return CONFIRMING_DATA

    match = re.match(r"^(gender|role|size|dept)_(.+)$", data)
    if not match:
        return CONFIRMING_DATA

    prefix, value = match.groups()
    field_map = {
        "gender": "Gender",
        "role": "Role",
        "size": "Size",
        "dept": "Department",
    }
    field = field_map[prefix]

    participant_data = context.user_data.get("parsed_participant", {})
    updated_data, _changes = update_single_field(participant_data, field, value)
    context.user_data["parsed_participant"] = updated_data
    context.user_data.pop("field_to_edit", None)

    if job := context.user_data.pop("clear_edit_job", None):
        job.schedule_removal()

    await show_confirmation(update, context, updated_data)
    return CONFIRMING_DATA


@smart_cleanup_on_error
async def handle_continue_editing_callback(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Shows the edit keyboard again when user chooses to continue editing."""
    query = update.callback_query
    await query.answer()

    participant_data = context.user_data.get("parsed_participant", {})
    keyboard = get_edit_keyboard(participant_data)

    msg = await query.message.reply_text(
        "\u270f\ufe0f –í—ã–±–µ—Ä–∏—Ç–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.",
        parse_mode="Markdown",
        reply_markup=keyboard,
    )
    _add_message_to_cleanup(context, msg.message_id)

    return CONFIRMING_DATA


@smart_cleanup_on_error
async def handle_duplicate_callback(
    update: Update, context: ContextTypes.DEFAULT_TYPE
) -> int:
    """Handles duplicate confirmation buttons."""
    query = update.callback_query
    await query.answer()

    action = query.data
    participant_data = context.user_data.get("parsed_participant", {})

    if action == "dup_add_new":
        try:
            new_participant = participant_service.add_participant(participant_data)
        except ValidationError as e:
            await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")
            return ConversationHandler.END
        except ParticipantNotFoundError as e:  # unlikely here
            await query.message.reply_text(str(e))
            return ConversationHandler.END
        except (DatabaseError, BotException) as e:
            logger.error("Error adding participant: %s", e)
            await query.message.reply_text(
                "‚ùå –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞."
            )
            return ConversationHandler.END
        cleanup_user_data_safe(context, update.effective_user.id)

        await query.message.reply_text(
            f"‚úÖ **–£—á–∞—Å—Ç–Ω–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω –∫–∞–∫ –Ω–æ–≤—ã–π (–≤–æ–∑–º–æ–∂–µ–Ω –¥—É–±–ª—å)**\n\n"
            f"üÜî ID: {new_participant.id}\n"
            f"üë§ –ò–º—è: {participant_data['FullNameRU']}\n\n"
            f"‚ö†Ô∏è –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –≤–æ–∑–º–æ–∂–Ω–æ–µ –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ!",
            parse_mode="Markdown",
            reply_markup=get_post_action_keyboard(),
        )

    elif action == "dup_replace":
        existing = participant_service.check_duplicate(participant_data["FullNameRU"])
        if existing:
            try:
                updated = participant_service.update_participant(
                    existing.id, participant_data
                )
            except ValidationError as e:
                await query.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏: {e}")
                return ConversationHandler.END
            except ParticipantNotFoundError as e:
                await query.message.reply_text(str(e))
                return ConversationHandler.END
            except (DatabaseError, BotException) as e:
                logger.error("Error updating participant: %s", e)
                await query.message.reply_text(
                    "‚ùå –û—à–∏–±–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —É—á–∞—Å—Ç–Ω–∏–∫–∞."
                )
                return ConversationHandler.END
            cleanup_user_data_safe(context, update.effective_user.id)

            if updated:
                await query.message.reply_text(
                    f"üîÑ **–£—á–∞—Å—Ç–Ω–∏–∫ –æ–±–Ω–æ–≤–ª–µ–Ω!**\n\n"
                    f"üÜî ID: {existing.id}\n"
                    f"üë§ –ò–º—è: {participant_data['FullNameRU']}\n"
                    f"üë• –†–æ–ª—å: {participant_data['Role']}\n\n"
                    f"üìã –î–∞–Ω–Ω—ã–µ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–æ–≤—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏",
                    parse_mode="Markdown",
                    reply_markup=get_post_action_keyboard(),
                )
            else:
                await query.message.reply_text("‚ùå –û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —É—á–∞—Å—Ç–Ω–∏–∫–∞.")
        else:
            await query.message.reply_text("‚ùå –°—É—â–µ—Å—Ç–≤—É—é—â–∏–π —É—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    return ConversationHandler.END


# –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    logger.error(
        f"Bot error for update {update}: {context.error}", exc_info=context.error
    )


# –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è
def main():
    # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
    init_database()

    # –ó–∞–≥—Ä—É–∂–∞–µ–º —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ –≤ –∫—ç—à
    load_reference_data()

    # –°–æ–∑–¥–∞–µ–º –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ
    application = Application.builder().token(BOT_TOKEN).build()

    add_conv = ConversationHandler(
        entry_points=[
            CommandHandler("add", add_command),
            CallbackQueryHandler(handle_add_callback, pattern="^main_add$"),
        ],
        states={
            COLLECTING_DATA: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_partial_data)
            ],
            CONFIRMING_DATA: [
                CallbackQueryHandler(
                    handle_save_confirmation, pattern="^confirm_save$"
                ),
                CallbackQueryHandler(
                    handle_enum_selection,
                    pattern="^(gender|role|size|dept)_.+$",
                ),
                CallbackQueryHandler(
                    handle_enum_selection,
                    pattern="^manual_input_.+$",
                ),
                MessageHandler(
                    filters.TEXT & ~filters.COMMAND, handle_participant_confirmation
                ),
                CallbackQueryHandler(edit_field_callback, pattern="^edit_"),
                CallbackQueryHandler(
                    handle_continue_editing_callback, pattern="^continue_editing$"
                ),
            ],
            CONFIRMING_DUPLICATE: [
                CallbackQueryHandler(handle_duplicate_callback, pattern="^dup_"),
            ],
        },
        fallbacks=[
            CommandHandler("cancel", cancel_command),
            CallbackQueryHandler(cancel_callback, pattern="^main_cancel$"),
        ],
    )
    # ConversationHandler –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω –ø–µ—Ä–≤—ã–º
    application.add_handler(add_conv)

    # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –∫–æ–º–∞–Ω–¥
    application.add_handler(CommandHandler("start", start_command))
    application.add_handler(CommandHandler("help", help_command))
    application.add_handler(
        CallbackQueryHandler(
            handle_main_menu_callback, pattern="^main_(list|export|help|menu|cancel)$"
        )
    )
    application.add_handler(CommandHandler("edit", edit_command))
    application.add_handler(CommandHandler("edit_field", edit_field_command))
    application.add_handler(CommandHandler("delete", delete_command))
    application.add_handler(CommandHandler("list", list_command))
    application.add_handler(CommandHandler("export", export_command))
    application.add_handler(CommandHandler("cancel", cancel_command))

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö —Å–æ–æ–±—â–µ–Ω–∏–π
    application.add_handler(
        MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message)
    )

    # –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –æ—à–∏–±–æ–∫
    application.add_error_handler(error_handler)

    print(f"ü§ñ –ë–æ—Ç @{BOT_USERNAME} –∑–∞–ø—É—â–µ–Ω!")
    print("üîÑ Polling started...")

    # –ó–∞–ø—É—Å–∫–∞–µ–º –±–æ—Ç–∞
    application.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == "__main__":
    main()
