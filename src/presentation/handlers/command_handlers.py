from datetime import datetime
from telegram import InlineKeyboardButton, InlineKeyboardMarkup, Update
from telegram.ext import ContextTypes, ConversationHandler

from application.use_cases.search_participant import SearchParticipantsQuery
from application.use_cases.update_participant import UpdateParticipantCommand
from presentation.handlers.base_handler import BaseHandler
from utils.decorators import require_role
from utils.session_recovery import detect_interrupted_session, handle_session_recovery
from messages import MESSAGES
from states import COLLECTING_DATA
from main import (
    _cleanup_messages,
    _show_main_menu,
    _record_action,
    _log_session_end,
    _send_response_with_menu_button,
    _show_search_prompt,
)
from presentation.ui.formatters.participant_formatter import format_participant


class StartCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self._handle = require_role("viewer")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        _log_session_end(context, user_id)
        context.user_data["session_start"] = datetime.utcnow()
        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/start"}
            )
        _record_action(context, "/start:start")

        if self.logger:
            self.logger.info("User %s started /start", user_id)
        await _cleanup_messages(context, update.effective_chat.id)
        await _show_main_menu(update, context)
        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_end", {"command": "/start"}
            )

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)


class AddCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        from main import cleanup_on_error

        self._handle = require_role("coordinator")(
            cleanup_on_error(self._handle)
        )

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/add"}
            )
        _record_action(context, "/add:start")

        context.user_data["add_flow_data"] = {
            "FullNameRU": None,
            "Gender": None,
            "Size": None,
            "Church": None,
            "Role": None,
            "Department": None,
            "FullNameEN": None,
            "CountryAndCity": None,
            "SubmittedBy": None,
            "ContactInformation": None,
        }

        cancel_markup = InlineKeyboardMarkup(
            [[InlineKeyboardButton("‚ùå –û—Ç–º–µ–Ω–∞", callback_data="main_cancel")]]
        )

        msg1 = await update.message.reply_text(
            "üöÄ **–ù–∞—á–∏–Ω–∞–µ–º –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞.**\n\n"
            "–û—Ç–ø—Ä–∞–≤—å—Ç–µ –¥–∞–Ω–Ω—ã–µ –ª—é–±—ã–º —É–¥–æ–±–Ω—ã–º —Å–ø–æ—Å–æ–±–æ–º:\n"
            "1Ô∏è‚É£ **–í—Å—Ç–∞–≤—å—Ç–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–Ω—ã–π —à–∞–±–ª–æ–Ω** (–ø—Ä–∏—à–ª—é –µ–≥–æ —Å–ª–µ–¥—É—é—â–∏–º —Å–æ–æ–±—â–µ–Ω–∏–µ–º).\n"
            "2Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ–ª–µ–π**, —Ä–∞–∑–¥–µ–ª—è—è –∏—Ö –∑–∞–ø—è—Ç–æ–π (`,`) –∏–ª–∏ –∫–∞–∂–¥–æ–µ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.\n"
            "3Ô∏è‚É£ **–û—Ç–ø—Ä–∞–≤–ª—è–π—Ç–µ –ø–æ –æ–¥–Ω–æ–º—É –ø–æ–ª—é** –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä, `–¶–µ—Ä–∫–æ–≤—å –ì—Ä–µ–π—Å`).\n\n"
            "*–î–ª—è —Å–∞–º–æ–π —Ç–æ—á–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∑–∞–ø—è—Ç—ã–µ –∏–ª–∏ –≤–≤–æ–¥ —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏.*\n"
            "–î–ª—è –æ—Ç–º–µ–Ω—ã –≤–≤–µ–¥–∏—Ç–µ /cancel.",
            parse_mode="Markdown",
            reply_markup=cancel_markup,
        )
        msg2 = await update.message.reply_text(MESSAGES["ADD_TEMPLATE"])
        from main import _add_message_to_cleanup

        _add_message_to_cleanup(context, msg1.message_id)
        _add_message_to_cleanup(context, msg2.message_id)
        _add_message_to_cleanup(context, update.message.message_id)
        context.user_data["current_state"] = COLLECTING_DATA
        if self.user_logger:
            self.user_logger.log_state_transition(
                user_id, "START", str(COLLECTING_DATA), {}
            )
        return COLLECTING_DATA

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)



class UpdateParticipantHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self.update_use_case = container.update_participant_use_case()
        self._handle = require_role("coordinator")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        participant_id = context.user_data.get("participant_id")
        data = context.user_data.get("parsed_participant", {})
        if participant_id is None:
            await update.message.reply_text("‚ùå –£—á–∞—Å—Ç–Ω–∏–∫ –Ω–µ –≤—ã–±—Ä–∞–Ω")
            return
        command = UpdateParticipantCommand(user_id=user_id, participant_id=participant_id, participant_data=data)
        participant = await self.update_use_case.execute(command)
        await update.message.reply_text(f"‚úèÔ∏è –£—á–∞—Å—Ç–Ω–∏–∫ '{participant.full_name_ru}' –æ–±–Ω–æ–≤–ª–µ–Ω")

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)

class HelpCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self._handle = require_role("viewer")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/help"}
            )
        _record_action(context, "/help:start")
        from main import get_user_role

        role = get_user_role(user_id)
        if self.logger:
            self.logger.info("User %s requested help", user_id)

        help_text = """
üìñ **–°–ø—Ä–∞–≤–∫–∞ –ø–æ –∫–æ–º–∞–Ω–¥–∞–º:**

üë• **–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞–º–∏:**
/add - –î–æ–±–∞–≤–∏—Ç—å –Ω–æ–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/edit - –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –¥–∞–Ω–Ω—ã–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞
/delete - –£–¥–∞–ª–∏—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∞

üìä **–ü—Ä–æ—Å–º–æ—Ç—Ä –¥–∞–Ω–Ω—ã—Ö:**
/list - –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
/export - –≠–∫—Å–ø–æ—Ä—Ç –¥–∞–Ω–Ω—ã—Ö –≤ CSV

‚ùì **–ü–æ–º–æ—â—å:**
/help - –ü–æ–∫–∞–∑–∞—Ç—å —ç—Ç—É —Å–ø—Ä–∞–≤–∫—É
/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/cancel - –û—Ç–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é –æ–ø–µ—Ä–∞—Ü–∏—é

üîç **–ü—Ä–∏–º–µ—Ä—ã –∑–∞–ø—Ä–æ—Å–æ–≤ (—Å–∫–æ—Ä–æ):**
"–°–∫–æ–ª—å–∫–æ team-member –≤ worship?"
"–ö—Ç–æ –∂–∏–≤–µ—Ç –≤ –∫–æ–º–Ω–∞—Ç–µ 203A?"
        """

        await _send_response_with_menu_button(update, help_text)
        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_end", {"command": "/help"}
            )

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)


class ListCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self.list_use_case = container.list_participants_use_case()
        self._handle = require_role("viewer")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/list"}
            )
        participants = await self.list_use_case.execute()

        if not participants:
            keyboard = self.ui_factory.create_add_participant_form()
            await update.message.reply_text(
                "üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤ –ø—É—Å—Ç**\n\n–î–æ–±–∞–≤—å—Ç–µ –ø–µ—Ä–≤–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞:",
                parse_mode="Markdown",
                reply_markup=keyboard,
            )
            if self.user_logger:
                self.user_logger.log_user_action(
                    user_id, "command_end", {"command": "/list", "count": 0}
                )
            return

        lines = [format_participant(p) for p in participants]
        message = "üìã **–°–ø–∏—Å–æ–∫ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤:**\n\n" + "\n".join(
            f"- {line}" for line in lines
        )
        keyboard = self.ui_factory.create_success_keyboard()
        await update.message.reply_text(
            message, parse_mode="Markdown", reply_markup=keyboard
        )

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id,
                "command_end",
                {"command": "/list", "count": len(participants)},
            )

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)


class SearchCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self.search_use_case = container.search_participants_use_case()
        self._handle = require_role("viewer")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/search"}
            )
        _record_action(context, "/search:start")
        text = update.message.text or ""
        parts = text.split(maxsplit=1)
        if len(parts) > 1:
            query_text = parts[1]
            results = await self.search_use_case.execute(SearchParticipantsQuery(query_text, user_id=user_id))
            if results:
                formatted = [f"- {r.participant.FullNameRU} (ID: {r.participant.id})" for r in results]
                message = "\n".join(formatted)
            else:
                message = "‚ùå –ù–∏—á–µ–≥–æ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
            await _send_response_with_menu_button(update, message)
            if self.user_logger:
                self.user_logger.log_user_action(user_id, "command_end", {"command": "/search", "count": len(results)})
            return ConversationHandler.END
        return await _show_search_prompt(update, context, is_callback=False)

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)


class CancelCommandHandler(BaseHandler):
    def __init__(self, container):
        super().__init__(container)
        self._handle = require_role("viewer")(self._handle)

    async def _handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
        user_id = update.effective_user.id
        if detect_interrupted_session(update, context):
            await handle_session_recovery(update, context)
            return

        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_start", {"command": "/cancel"}
            )
        _record_action(context, "/cancel:start")
        _log_session_end(context, user_id)
        if context.user_data:
            context.user_data.clear()
            if self.logger:
                self.logger.info("User %s cancelled the add flow.", user_id)
        else:
            if self.logger:
                self.logger.info(
                    "User %s cancelled a non-existent operation.", user_id
                )

        await _cleanup_messages(context, update.effective_chat.id)
        await _show_main_menu(update, context, is_return=True)
        if self.user_logger:
            self.user_logger.log_user_action(
                user_id, "command_end", {"command": "/cancel"}
            )
        return ConversationHandler.END

    async def handle(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        return await self._handle(update, context)
